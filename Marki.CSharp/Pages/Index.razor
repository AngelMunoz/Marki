@page "/"
@implements IDisposable
@using Marki.Core
@using static Marki.Core.Http
@using System.Reactive.Subjects
@using System.Linq
@using System.Reactive.Linq

<article class="blog-page blog-summary">
    <aside class="blog-search inner-card">
        <section>
            <h4>Search by Title And Tags</h4>
        </section>
        <input type="text" placeholder="Search a blog post" @oninput="@OnTextQuery">
        <ul>
            @foreach (var tag in Tags)
            {
                <li class="tag-list-item">
                    <label for="">
                        <input type="checkbox" checked="@tag.Item1" @onchange="@(e => OnTagChange(e, tag.Item2))">
                        @tag.Item2
                    </label>
                </li>
            }
        </ul>
    </aside>
    <section class="blog-content">
        <header class="page-header">
            <h1>The C# Web Assembly Blog</h1>
        </header>
        <ul class="blog-list inner-card">
            @foreach (var item in PaginatedContent?.Items ?? Enumerable.Empty<BlogPost>())
            {
                <li>
                    <h4>
                        <NavLink href='@($"/read/{item._id}")'>@item.Title</NavLink>
                    </h4>
                    <p>@GetSummary(item)</p>
                </li>
            }
        </ul>
    </section>
</article>

@code {
    public PaginatedResponse<BlogPost>? PaginatedContent { get; private set; }
    public List<(bool, string)> Tags { get; private set; } = new();

    public string? SearchText { get; private set; }
    public IEnumerable<string> SelectedTags { get; private set; } = Enumerable.Empty<string>();

    public Subject<string> OnInput { get; } = new();

    public Subject<IEnumerable<string>> OnTagsQuery { get; } = new();

    private Subject<string?> Destroy { get; } = new();

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        PaginatedContent = await Blogs.Find("");
        var tags = await Blogs.FindTags();
        Tags = tags.Select(x => (false, x)).ToList();
        RegisterObservables();
    }

    public void Dispose()
    {
        Destroy.OnNext(null);
        Destroy.OnCompleted();
        Destroy.Dispose();
    }

    protected string GetSummary(BlogPost item)
    {
        var truncateTo = 100;
        if (item.Content.Length < 100)
        {
            truncateTo = item.Content.Length;
        }
        var titleIndex = item.Content.IndexOf("##", StringComparison.InvariantCulture) switch
        {
            <= -1 => 0,
            var value => value
        };
        return Markdown.toText(item.Content.Substring(titleIndex, truncateTo));
    }

    protected void OnTextQuery(ChangeEventArgs args)
    {
        OnInput.OnNext(args.Value as string ?? string.Empty);
    }

    protected void OnTagChange(ChangeEventArgs args, string tag)
    {
        var value = args.Value is not null && (bool)args.Value;
        var tags = Tags.Select(item => tag.Equals(item.Item2) ? (value, tag) : (item.Item1, item.Item2)).ToArray();
        Tags = tags.ToList();
        SelectedTags = tags.Where(item => item.Item1).Select(item => item.Item2);
        OnTagsQuery.OnNext(SelectedTags);
    }

    private void RegisterObservables()
    {
        OnInput
        .AsObservable<string>()
        .TakeUntil(Destroy)
        .Throttle(TimeSpan.FromMilliseconds(500))
        .DistinctUntilChanged()
        .Select(async query => (query, await Blogs.Find(query)))
        .Switch()
        .Subscribe(content =>
        {
            var (query, response) = content;

            SearchText = query;
            PaginatedContent = response;
            StateHasChanged();
        });

        OnTagsQuery
        .AsObservable()
        .TakeUntil(Destroy)
        .Throttle(TimeSpan.FromMilliseconds(500))
        .DistinctUntilChanged()
        .Select(async tags =>
        {
            var t = tags.ToArray();
            return (t, await Blogs.Find(SearchText, t));
        })
        .Switch()
        .Subscribe(content =>
        {
            var (_, response) = content;
            PaginatedContent = response;
            StateHasChanged();
        });
    }

}
